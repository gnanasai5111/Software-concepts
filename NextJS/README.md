# Next Js
- Its a React framework to build full stack applications.

```
npx create-next-app@latest application-name
```

## Routing 
- Next.js uses File-Based Routing with the app/ directory (introduced in Next.js 13+).
- Routing is driven by the file and folder structure inside the app/ directory.

### Routing Convention
- All routes must reside in the app folder.
- A file named page.tsx or page.jsx is required in each route folder.
- Each folder represents a URL segment.

## Basic Routes
```
app/
├── layout.tsx
├── page.tsx         → '/'
├── about/
│   └── page.tsx     → '/about'
├── contact/
│   └── page.tsx     → '/contact'

```

## Nested Routes
- Nest folders to create Nested Routes
```
app/
└── blog/
    └── post/
        └── page.tsx → '/blog/post'
```

## Dynamic Routes
- Use square brackets [] to define a dynamic segment.
```
app/
└── products/
    └── [productId]/
        └── page.tsx → '/products/:productId'
```

Asynchronous Dynamic Routes(Server components)
```
import React from "react";

async function ProductDetails({
  params,
}: {
  params: Promise<{ productId: string }>;
}) {
  const { productId } = await params;
  return <div>ProductDetails of product {productId}</div>;
}

export default ProductDetails;
```

## Catch-All Segments
- Next.js supports dynamic routes using catch-all segments, allowing you to match variable-length URL paths.
- **[...slug]** - Matches any number of path segments, and returns them as an array.
```
app/docs/[...slug]/page.tsx

/docs/a → params.slug = ['a']

/docs/a/b/c → params.slug = ['a', 'b', 'c']
```
- **[[...slug]]** - Similar to catch-all, but also matches when no segment is provided (optional).
```
app/docs/[[...slug]]/page.tsx
/docs → params.slug = undefined

/docs/a → params.slug = ['a']

/docs/a/b → params.slug = ['a', 'b']
```

## 404 Page (Not Found)
- Next.js automatically renders a 404 page if no matching route is found.
- To customize this page, create a not-found.tsx file inside the app/ directory.
- In your dynamic route page, you can call notFound() from next/navigation to trigger a 404 response when certain conditions are met. This is useful if you want to display a 404 page based on specific conditions, such as an invalid productId or missing data.

```
import { notFound } from "next/navigation";
import React from "react";

function ProductDetails({ params }: { params: { productId: string } }) {
  const { productId } = params;
  if (parseInt(productId) > 1000) {
    notFound();
  }
  return <div>Product Details of product {productId}</div>;
}

export default ProductDetails;

"use client";
import { usePathname } from "next/navigation";
import React from "react";

function NotFound() {
  const pathname = usePathname();
  return <div>Product Id {pathname.split("/")[2]} not found</div>;
}

export default NotFound;
```
## File Colocation
- File Colocation refers to the practice of placing related files (such as components, styles, and tests) together in the same folder to improve organization and maintainability.
- You can use any file name (except page.tsx or page.ts) for other related files within the same URL segment folder.

## Private Folders
- Private folders are used to contain parts of your application that are not directly part of the public-facing route structure but may still be important for internal functionality (e.g., utilities, authentication, and helpers).Use underscore before a folder to make it as private folder
```
_lib
```

## Route Groups
- Route groups allow you to logically group related routes without affecting the URL structure. This is helpful for organizing and structuring deeply nested routes.
- Route groups are enclosed in parentheses () and it doesnt include in the url segment
```
(auth)
```
## Layouts
- Layouts in Next.js are used to define a shared structure (like headers, footers, navigation, etc.) for specific sections of your application.
- A layout file is created with the name layout.tsx or layout.jsx and placed in the appropriate folder.
```
export const metadata = {
  title: 'Next.js',
  description: 'Generated by Next.js',
}

export default function RootLayout({
  children,
}: {
  children: React.ReactNode
}) {
  return (
    <html lang="en">
      <body>{children}</body>
    </html>
  )
}
```

## Nested Layouts
- Nested layouts allow you to define different layouts at different levels of the app, enabling you to have specific layouts for specific routes or sections.
```
app/
├── layout.tsx           → Root layout, shared across the app
├── page.tsx             → Root page, accessible at '/'
├── dashboard/
│   ├── layout.tsx       → Dashboard layout, shared across dashboard pages
│   ├── page.tsx         → Dashboard homepage, accessible at '/dashboard'
│   └── settings/
│       └── layout.tsx   → Settings layout, shared across settings pages
│       └── page.tsx     → Settings page, accessible at '/dashboard/settings'

```

## Multiple Root Layouts
- Next.js supports having multiple root layouts for different sections of your app.
- This can be achieved using Route Groups which logically separate layouts into different categories while maintaining clean and organized routing.
```
app/
├── (auth)/
│   ├── layout.tsx       → auth-specific layout
│   └── login.tsx      
├── (app)/
│   ├── layout.tsx       → app-specific layout
│   └── page.tsx       

```

## Metadata
- Next.js (App Router) allows you to define metadata (like title, description etc.) for SEO and social sharing.
-  Metadata can be set:
1. Statically using the metadata object
2. Dynamically using the generateMetadata function

### Static Metadata
- Define a metadata object at the top of a page.tsx or layout.tsx file.
```
export const metadata = {
  title: "Home Page",
  description: "Welcome to the home page!",
};
```

###  Dynamic Metadata
- Use generateMetadata to create metadata based on route params or fetched data.
  
```
import { Metadata } from "next";

export async function generateMetadata({
  params,
}: {
  params: { productId: string };
}): Promise<Metadata> {
  const { productId } = await params;

  return {
    title: `Product - ${productId}`,
    description: `Details of product with ID ${productId}`,
  };
}
```
- You can define a title using either a simple string, or a structured object with default, template, or absolute.
- Default : Acts as a fallback title when no specific title is set by the page.
- Template : Defines a reusable format (like prefix or suffix) for page titles.
- Absolute: Ignores both default and template and sets the title exactly as specified.

## Links
- To to navigate between routes .
```
import Link from "next/link";

<Link href="/about">About</Link>
```

## Active Link
- Use usePathname() from next/navigation to determine the current path and apply styles accordingly.
```
"use client";
import { usePathname } from "next/navigation";
import Link from "next/link";

const NavLink = ({ href, label }: { href: string; label: string }) => {
  const pathname = usePathname();
  const isActive = pathname === href;

  return (
    <Link href={href} className={isActive ? "text-blue-500" : "text-gray-500"}>
      {label}
    </Link>
  );
};
```

## Programmatic Navigation
- Use useRouter() from next/navigation to navigate manually.
```
"use client";
import { useRouter } from "next/navigation";

const Button = () => {
  const router = useRouter();

  const goToProduct = () => {
    router.push("/products/123");
  };

  return <button onClick={goToProduct}>Go to Product</button>;
};
```

## Params and search Params

- In Next.js 15, both params and searchParams can be promises when passed to server components.

```
import { notFound } from "next/navigation";
import React from "react";

type props = {
  params: Promise<{ productId: string }>;
  searchParams: Promise<{ name: string }>;
};

async function ProductDetails({ params, searchParams }: props) {
  const { productId } = await params;
  const { name } =await searchParams;
  if (parseInt(productId) > 1000) {
    notFound();
  }
  return (
    <div>
      Product Details of product {productId} of name {name}
    </div>
  );
}

export default ProductDetails;
```

- In Client components , you can access by use from react
- use() is the hook used to consume asynchronous data from a Promise (like params or searchParams), while keeping everything declarative.
```
"use client";
import { notFound } from "next/navigation";
import React, { use } from "react";

type props = {
  params: Promise<{ productId: string }>;
  searchParams: Promise<{ name: string }>;
};

function ProductDetails({ params, searchParams }: props) {
  const { productId } = use(params);
  const { name } = use(searchParams);
  if (parseInt(productId) > 1000) {
    notFound();
  }
  return (
    <div>
      Product Details of product {productId} of name {name}
    </div>
  );
}

export default ProductDetails;
```

## useSearchParams()

- You can also use this hook in client components to access search Params
```
const searchParams = useSearchParams();
console.log(searchParams.get("name"))
```

## Templates
- A template.tsx is like a layout.tsx but is re-rendered on every navigation instead of being persistent.
- Use it when you want a fresh state for every route render (e.g., animations, modal resets).
- File name: template.tsx or template.jsx.

## Loading 
- Used to show a loading indicator during suspense, including page.tsx, layout.tsx, or template.tsx
- File: loading.tsx or loading.jsx
- Can be a server or client component.

## Error
- Used to catch and display render or data-fetching errors for a specific segment.
- File: error.tsx or error.jsx
- Must be a client component.
-  reset() is used to reattempt rendering the segment.

```
'use client';

export default function Error({ error, reset }: { error: Error; reset: () => void }) {
  return (
    <div>
      <h2>Error: {error.message}</h2>
      <button onClick={reset}>Try again</button>
    </div>
  );
}
```

## Parellel Routes
- Its an advance routing mechanism that allows you to simultaneously or conditionally render one or more pages within the same layout.

**Traditional Approach (Before Parallel Routes)** 
```
import React from 'react'
function Dashboard() {
  return (
    <div>Dashboard</div>
    <Users />
    <Data />
    <Photos />
  )
}
export default Dashboard
```
**Slots** : Parallel routes are created using named slots. Slots are defined with the @folder convention. 
For example, the following file structure defines three slots: @users,@photos and @data.
- Slots are passed as props to the shared parent layout.
- For the example above, the component in DashboardLayout now accepts the @users,@photos and @data slots props, and can render them in parallel alongside the children prop
```
/app/dashboard/layout.tsx
/app/dashboard/page.tsx            → children
/app/dashboard/@users/page.tsx    → users slot
/app/dashboard/@data/page.tsx     → data slot
/app/dashboard/@photos/page.tsx   → photos slot

import React from "react";

type DashboardProps = {
  children: React.ReactNode;
  users: React.ReactNode;
  photos: React.ReactNode;
  data: React.ReactNode;
};

function DashboardLayout({ children, users, photos, data }: DashboardProps) {
  return (
    <div>
      {children}
      {users}
      {photos}
      {data}
    </div>
  );
}

export default DashboardLayout;
```

### unmatched Routes

- Soft Navigation: During client-side navigation, Next.js will perform a partial render, changing the subpage within the slot, while maintaining the other slot's active subpages, even if they don't match the current URL.
- Hard Navigation: After a full-page load (browser refresh), Next.js cannot determine the active state for the slots that don't match the current URL. Instead, it will render a default.js file for the unmatched slots, or 404 if default.js doesn't exist.

**default.js** -You can define a default.js file to render as a fallback for unmatched slots during the initial load or full-page reload.


- When using Parallel Routes in Next.js, nested routes inside a slot (like /dashboard/users/userDetails) can cause issues on hard reloads.
- During soft navigation (via <Link>), all slots stay active.
- But on hard refresh, Next.js tries to match the URL in each slot.If a slot (like @data or @photos) doesn’t match the current path, it throws a 404 — unless a default.tsx is provided.

```
/app/dashboard/@users/page.tsx          → users slot
/app/dashboard/@users/userDetails/page.tsx → Nested Route
/app/dashboard/@users/default.tsx       → fallback for users slot

/app/dashboard/@data/page.tsx           → data slot
/app/dashboard/@data/default.tsx        → fallback for data slot

/app/dashboard/@photos/page.tsx         → photos slot
/app/dashboard/@photos/default.tsx      → fallback for photos slot

/app/dashboard/default.tsx              → fallback for children
```

## Conditional Routes

- It lets you render slots based on conditions.

```
import React from "react";

type DashboardProps = {
  children: React.ReactNode;
  users: React.ReactNode;
  photos: React.ReactNode;
  data: React.ReactNode;
  login:React.ReactNode;
};

function DashboardLayout({ children, users, photos, data,login }: DashboardProps) {
    const isLoggedIn=false;
  return isLoggedIn ? <div>
      {children}
      {users}
      {photos}
      {data}
    </div>: login
}

export default DashboardLayout;
```

## Intercepting routes
- Intercepting routes allows you to load a route from another part of your application within the current layout.

consider an example
- For example, when clicking on a photo in a feed, you can display the photo in a modal, overlaying the feed. In this case, Next.js intercepts the /photo/123 route, masks the URL, and overlays it over /feed.
- However, when navigating to the photo by clicking a shareable URL or by refreshing the page, the entire photo page should render instead of the modal. No route interception should occur.

Conventions 
- Intercepting routes can be defined with the (..) convention, which is similar to relative path convention ../ but for segments.
1. (.) to match segments on the same level
2. (..) to match segments one level above
3. (..)(..) to match segments two levels above
4. (...) to match segments from the root app directory

```
app
├── feed
│   ├── layout.js
│   └── (..)photo
│       └── [id]
│           └── page.js         # Intercepted modal route for photo
├── photo
│   └── [id]
│       └── page.js             # Full-page photo view (for hard navigation)
├── layout.js
└── page.js
```

- (..)photo/[id]/page.js: This route intercepts /photo/:id and renders it as a modal when accessed from /feed.
- photo/[id]/page.js: Fallback full-page route if the user refreshes or directly lands on /photo/:id.
  





